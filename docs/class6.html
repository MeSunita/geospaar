<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Geospatial Analysis with R</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.20/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/lucy.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/middlebury-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="themes/class6.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Geospatial Analysis with R
]
.subtitle[
## Class 6
]

---



```r
s3url &lt;- glue::glue("/vsis3/activemapper/",
                    "planet/composite_sr_buf_fix/GS/",
                    "tile486317_736815_736967.tif")  # not accessible
b &lt;- raster::brick(s3url)[[4:2]]
png(here::here("external/slides/figures/ghana_planet.png"), height = 4, 
    width = 4, units  = "in", res = 300, bg = "transparent")
raster::plotRGB(b, stretch = "lin")
dev.off()
```


---

# Today

- Review of birthday problem
- Object oriented (OO) programming
- Environments in R
- Indexing
- Coding practice

---
# The R Ecosystem

&lt;img src="figures/class5_u1m2.png" width="70%" style="display: block; margin: auto;" /&gt;


---
## BIRTHDAY PROBLEM

We want to use R to answer the birthday problem. If you have n people in a room with random birthdays, do any two people share the same birthday?

Some assumptions.
- No Feb 29 birthdays
- All birthdays are equally likely.

Questions
- How can we represent all birthdays as a numeric vector?
- How can we use sampling to represent birthdays of different people?

---
## BIRTHDAY PROBLEM

- Build a function that randomly generates birthdays for n people. The function should return `TRUE` if two people share a birthday, and `FALSE` otherwise.

```r
birthday_function &lt;- function(no_people){
  ......
  if(....){
    return(TRUE) ## TRUE means that at least two people have the same birthday
  } else {
    return(FALSE) ## FALSE means that no people have the same birthday
  }
}
```
---
## BIRTHDAY PROBLEM

- Use the `birthday_function` to create a logical vector v of length 100. 

Each value of v should represent 1 run of the `birthday_function`. So v[10] is a test of the birthday_function on 10 people, v[25] represents a test of `birthday_function` on 25 people, etc.

Create a plot of number of people (x-axis) vs v (y-axis). It might look something like what's on the next slide.

---
## BIRTHDAY PROBLEM

```r
number_people &lt;- 1:10
v &lt;- c(FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)
plot(number_people, v)
```

![](class6_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---
## BIRTHDAY PROBLEM (CHALLENGE)

- Build a function that runs many simulations of the birthday function. The function should return the percent of time that two people have the same birthday.

For example, you want to run the function for 25 people, and 10,000 simulations. The function should return the percent of simulations in which 2 of the 25 people share a birthday.

You can use `mean` on a logical vector.


```r
mean(c(TRUE, TRUE, FALSE, TRUE))
```

```
## [1] 0.75
```

```r
birthday_sims &lt;- function(no_people, no_simulations){
  ......
  return(mean(....))
}
```

---


## OO (Object oriented programming)

- Procedural versus object-oriented (OO) programming
- OO bundles together data and functions into an object
- Class defines type/structure of object and what methods (functions) are used with it
- 3+ types of OO in R

---

## OO - Base system? 

A vector is a base object.

```r
x &lt;- 1:10
!is.object(x)  # if TRUE, base object. 
```

```
## [1] TRUE
```

```r
str(x)
```

```
##  int [1:10] 1 2 3 4 5 6 7 8 9 10
```

A data frame is not a base object.

```r
DF &lt;- data.frame(v1  = c(1,2,3), v2 = c(4,5,6))
!is.object(DF)  # if TRUE, base object. 
```

```
## [1] FALSE
```

```r
str(DF)
```

```
## 'data.frame':	3 obs. of  2 variables:
##  $ v1: num  1 2 3
##  $ v2: num  4 5 6
```

---
## 00 - S3 system?
A data frame is S3 object.

```r
DF &lt;- data.frame(v1  = c(1,2,3), v2 = c(4,5,6))
!is.object(DF)  # if TRUE, base object. 
```

```
## [1] FALSE
```

```r
!isS4(DF)  # it’s S3
```

```
## [1] TRUE
```

```r
str(DF)
```

```
## 'data.frame':	3 obs. of  2 variables:
##  $ v1: num  1 2 3
##  $ v2: num  4 5 6
```

---
## 00 - S3 system?
A lm (linear model) is S3 object.

```r
a &lt;- 1:10
x &lt;- lm(a ~ rev(a))
!is.object(x)  # if TRUE, base object. 
```

```
## [1] FALSE
```

```r
!isS4(x)  # it’s S3
```

```
## [1] TRUE
```

```r
str(x)
```

```
## List of 12
##  $ coefficients : Named num [1:2] 11 -1
##   ..- attr(*, "names")= chr [1:2] "(Intercept)" "rev(a)"
##  $ residuals    : Named num [1:10] 3.13e-15 -3.46e-15 -2.13e-16 -1.80e-16 -3.55e-17 ...
##   ..- attr(*, "names")= chr [1:10] "1" "2" "3" "4" ...
##  $ effects      : Named num [1:10] -1.74e+01 9.08 -4.44e-16 -7.77e-16 -9.99e-16 ...
##   ..- attr(*, "names")= chr [1:10] "(Intercept)" "rev(a)" "" "" ...
##  $ rank         : int 2
##  $ fitted.values: Named num [1:10] 1 2 3 4 5 ...
##   ..- attr(*, "names")= chr [1:10] "1" "2" "3" "4" ...
##  $ assign       : int [1:2] 0 1
##  $ qr           :List of 5
##   ..$ qr   : num [1:10, 1:2] -3.162 0.316 0.316 0.316 0.316 ...
##   .. ..- attr(*, "dimnames")=List of 2
##   .. .. ..$ : chr [1:10] "1" "2" "3" "4" ...
##   .. .. ..$ : chr [1:2] "(Intercept)" "rev(a)"
##   .. ..- attr(*, "assign")= int [1:2] 0 1
##   ..$ qraux: num [1:2] 1.32 1.27
##   ..$ pivot: int [1:2] 1 2
##   ..$ tol  : num 1e-07
##   ..$ rank : int 2
##   ..- attr(*, "class")= chr "qr"
##  $ df.residual  : int 8
##  $ xlevels      : Named list()
##  $ call         : language lm(formula = a ~ rev(a))
##  $ terms        :Classes 'terms', 'formula'  language a ~ rev(a)
##   .. ..- attr(*, "variables")= language list(a, rev(a))
##   .. ..- attr(*, "factors")= int [1:2, 1] 0 1
##   .. .. ..- attr(*, "dimnames")=List of 2
##   .. .. .. ..$ : chr [1:2] "a" "rev(a)"
##   .. .. .. ..$ : chr "rev(a)"
##   .. ..- attr(*, "term.labels")= chr "rev(a)"
##   .. ..- attr(*, "order")= int 1
##   .. ..- attr(*, "intercept")= int 1
##   .. ..- attr(*, "response")= int 1
##   .. ..- attr(*, ".Environment")=&lt;environment: R_GlobalEnv&gt; 
##   .. ..- attr(*, "predvars")= language list(a, rev(a))
##   .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
##   .. .. ..- attr(*, "names")= chr [1:2] "a" "rev(a)"
##  $ model        :'data.frame':	10 obs. of  2 variables:
##   ..$ a     : int [1:10] 1 2 3 4 5 6 7 8 9 10
##   ..$ rev(a): int [1:10] 10 9 8 7 6 5 4 3 2 1
##   ..- attr(*, "terms")=Classes 'terms', 'formula'  language a ~ rev(a)
##   .. .. ..- attr(*, "variables")= language list(a, rev(a))
##   .. .. ..- attr(*, "factors")= int [1:2, 1] 0 1
##   .. .. .. ..- attr(*, "dimnames")=List of 2
##   .. .. .. .. ..$ : chr [1:2] "a" "rev(a)"
##   .. .. .. .. ..$ : chr "rev(a)"
##   .. .. ..- attr(*, "term.labels")= chr "rev(a)"
##   .. .. ..- attr(*, "order")= int 1
##   .. .. ..- attr(*, "intercept")= int 1
##   .. .. ..- attr(*, "response")= int 1
##   .. .. ..- attr(*, ".Environment")=&lt;environment: R_GlobalEnv&gt; 
##   .. .. ..- attr(*, "predvars")= language list(a, rev(a))
##   .. .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
##   .. .. .. ..- attr(*, "names")= chr [1:2] "a" "rev(a)"
##  - attr(*, "class")= chr "lm"
```

---
## Accessing data in S3 objects.

- Access by name using $

```r
a &lt;- 1:10
x &lt;- lm(a ~ rev(a))
print(names(x))
```

```
##  [1] "coefficients"  "residuals"     "effects"       "rank"         
##  [5] "fitted.values" "assign"        "qr"            "df.residual"  
##  [9] "xlevels"       "call"          "terms"         "model"
```

```r
print(x$coefficients)
```

```
## (Intercept)      rev(a) 
##          11          -1
```

```r
(x$residuals)
```

```
##             1             2             3             4             5 
##  3.125393e-15 -3.461222e-15 -2.128087e-16 -1.796631e-16 -3.549525e-17 
##             6             7             8             9            10 
##  2.196949e-16  3.638628e-16  2.859861e-16 -2.359798e-16  1.302327e-16
```

---
## Accessing data in S3 objects.

- Access by name or index using `[[ ]]`

```r
DF &lt;- data.frame(v1  = c(1,2,3), v2 = c(4,5,6))
print(DF$v2) # prints column named "v2"
```

```
## [1] 4 5 6
```

```r
print(DF[[2]]) # prints second column
```

```
## [1] 4 5 6
```

---
## OO - S4 system? 

```r
x &lt;- raster::raster(nrow = 10, ncol = 10)
!is.object(x)  # if TRUE, base object. 
```

```
## [1] FALSE
```

```r
!isS4(x)  # it’s S3
```

```
## [1] FALSE
```

```r
!is(x, "refClass") # if TRUE it’s S4; otherwise it’s RC.
```

```
## [1] TRUE
```

```r
str(x)
```

```
## Formal class 'RasterLayer' [package "raster"] with 13 slots
##   ..@ file    :Formal class '.RasterFile' [package "raster"] with 13 slots
##   .. .. ..@ name        : chr ""
##   .. .. ..@ datanotation: chr "FLT4S"
##   .. .. ..@ byteorder   : chr "little"
##   .. .. ..@ nodatavalue : num -Inf
##   .. .. ..@ NAchanged   : logi FALSE
##   .. .. ..@ nbands      : int 1
##   .. .. ..@ bandorder   : chr "BIL"
##   .. .. ..@ offset      : int 0
##   .. .. ..@ toptobottom : logi TRUE
##   .. .. ..@ blockrows   : int 0
##   .. .. ..@ blockcols   : int 0
##   .. .. ..@ driver      : chr ""
##   .. .. ..@ open        : logi FALSE
##   ..@ data    :Formal class '.SingleLayerData' [package "raster"] with 13 slots
##   .. .. ..@ values    : logi(0) 
##   .. .. ..@ offset    : num 0
##   .. .. ..@ gain      : num 1
##   .. .. ..@ inmemory  : logi FALSE
##   .. .. ..@ fromdisk  : logi FALSE
##   .. .. ..@ isfactor  : logi FALSE
##   .. .. ..@ attributes: list()
##   .. .. ..@ haveminmax: logi FALSE
##   .. .. ..@ min       : num Inf
##   .. .. ..@ max       : num -Inf
##   .. .. ..@ band      : int 1
##   .. .. ..@ unit      : chr ""
##   .. .. ..@ names     : chr ""
##   ..@ legend  :Formal class '.RasterLegend' [package "raster"] with 5 slots
##   .. .. ..@ type      : chr(0) 
##   .. .. ..@ values    : logi(0) 
##   .. .. ..@ color     : logi(0) 
##   .. .. ..@ names     : logi(0) 
##   .. .. ..@ colortable: logi(0) 
##   ..@ title   : chr(0) 
##   ..@ extent  :Formal class 'Extent' [package "raster"] with 4 slots
##   .. .. ..@ xmin: num -180
##   .. .. ..@ xmax: num 180
##   .. .. ..@ ymin: num -90
##   .. .. ..@ ymax: num 90
##   ..@ rotated : logi FALSE
##   ..@ rotation:Formal class '.Rotation' [package "raster"] with 2 slots
##   .. .. ..@ geotrans: num(0) 
##   .. .. ..@ transfun:function ()  
##   ..@ ncols   : int 10
##   ..@ nrows   : int 10
##   ..@ crs     :Formal class 'CRS' [package "sp"] with 1 slot
##   .. .. ..@ projargs: chr "+proj=longlat +datum=WGS84 +no_defs"
##   .. .. ..$ comment: chr "GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.25722"| __truncated__
##   ..@ srs     : chr "GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.25722"| __truncated__
##   ..@ history : list()
##   ..@ z       : list()
```

---

## Accessing data in S4 objects.

- Print slots using `slotNames()`
- Access slots using `@`

```r
library(raster)
```

```
## Loading required package: sp
```

```r
x &lt;- raster::raster(nrow = 10, ncol = 10, vals = 3)
print(slotNames(x))
```

```
##  [1] "file"     "data"     "legend"   "title"    "extent"   "rotated" 
##  [7] "rotation" "ncols"    "nrows"    "crs"      "srs"      "history" 
## [13] "z"
```

```r
print(x@ncols)
```

```
## [1] 10
```

---

## Accessing data in S4 objects.
- Generally you want to use designed methods to set new values in slots. 


```r
print("old values")
```

```
## [1] "old values"
```

```r
print( x@data@values)
```

```
##   [1] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
##  [38] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
##  [75] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```

```r
x &lt;- setValues(x, sample(1:100, size = 100, replace = T))## set values of raster
print("new values")
```

```
## [1] "new values"
```

```r
print( x@data@values)
```

```
##   [1]  76  25   6  88  16  20   8  46   3  58  61  46  68  39  10  16  83  20
##  [19]   4   5  19  25  34  42  72  41  18   5   9  17   7  51  90  97  11  90
##  [37]  41  57  77  33  85   7  96  52  35  18  37  86  24  71  23  78  83  44
##  [55]  34  55  13   9  41  11  80  48 100  64  81  13  52  50  35 100  16  85
##  [73]  56  22  20  82  68  94  84  22   5  52  56  45  38  99  79  95  84   2
##  [91]  19  54  39  84  33   7   4  80  71  56
```

---
## Functions
- Primitives (e.g. `c`)
- Operators (e.g. +, -)
- Control structures (e.g. `for`, `if`, `apply`)
- Package functions (e.g. `dplyr::select`)
- Generic functions

---

## Functions
### Components


```r
function_name &lt;- function(arg1, 
                          arg2 = 1:10, 
                          arg3 = ifelse(arg2 == 2, TRUE, FALSE)) {
  body
}
```

Three components of a function:
- `formals()`: arguments
- `body()`, the code, which returns the last object generated, unless specified with `return(x)`.
- `environment()`, function finds the values

Unnamed functions are **anonymous** functions. 


---
## Primitive functions
List primitive functions

```r
names(methods:::.BasicFunsList)
```

```
##   [1] "$"                    "$&lt;-"                  "["                   
##   [4] "[&lt;-"                  "[["                   "[[&lt;-"                
##   [7] "%*%"                  "xtfrm"                "c"                   
##  [10] "all"                  "any"                  "sum"                 
##  [13] "prod"                 "max"                  "min"                 
##  [16] "range"                "is.matrix"            "&gt;="                  
##  [19] "cosh"                 "cummax"               "dimnames&lt;-"          
##  [22] "as.raw"               "log2"                 "tan"                 
##  [25] "dim"                  "as.logical"           "^"                   
##  [28] "is.finite"            "sinh"                 "log10"               
##  [31] "as.numeric"           "dim&lt;-"                "is.array"            
##  [34] "tanpi"                "gamma"                "atan"                
##  [37] "as.integer"           "Arg"                  "signif"              
##  [40] "cumprod"              "cos"                  "length"              
##  [43] "!="                   "digamma"              "exp"                 
##  [46] "floor"                "acos"                 "seq.int"             
##  [49] "abs"                  "length&lt;-"             "sqrt"                
##  [52] "!"                    "acosh"                "is.nan"              
##  [55] "Re"                   "tanh"                 "names"               
##  [58] "cospi"                "&amp;"                    "anyNA"               
##  [61] "trunc"                "cummin"               "levels&lt;-"            
##  [64] "*"                    "Mod"                  "|"                   
##  [67] "names&lt;-"              "+"                    "log"                 
##  [70] "lgamma"               "as.complex"           "asinh"               
##  [73] "-"                    "sin"                  "/"                   
##  [76] "as.environment"       "&lt;="                   "as.double"           
##  [79] "is.infinite"          "is.numeric"           "rep"                 
##  [82] "round"                "sinpi"                "dimnames"            
##  [85] "asin"                 "as.character"         "%/%"                 
##  [88] "is.na"                "&lt;"                    "&gt;"                   
##  [91] "Im"                   "%%"                   "trigamma"            
##  [94] "=="                   "cumsum"               "atanh"               
##  [97] "sign"                 "ceiling"              "Conj"                
## [100] "as.call"              "log1p"                "expm1"               
## [103] "("                    ":"                    "="                   
## [106] "@"                    "{"                    "~"                   
## [109] "&amp;&amp;"                   ".C"                   "baseenv"             
## [112] "quote"                "::"                   "&lt;-"                  
## [115] "is.name"              "if"                   "||"                  
## [118] "attr&lt;-"               "untracemem"           ".cache_class"        
## [121] "substitute"           "interactive"          "is.call"             
## [124] "switch"               "function"             "is.single"           
## [127] "is.null"              "is.language"          "is.pairlist"         
## [130] ".External.graphics"   "globalenv"            "class&lt;-"             
## [133] ".Primitive"           "is.logical"           "enc2utf8"            
## [136] "UseMethod"            ".subset"              "proc.time"           
## [139] "enc2native"           "repeat"               ":::"                 
## [142] "&lt;&lt;-"                  "@&lt;-"                  "missing"             
## [145] "nargs"                "isS4"                 ".isMethodsDispatchOn"
## [148] "forceAndCall"         ".primTrace"           "storage.mode&lt;-"      
## [151] ".Call"                "unclass"              "gc.time"             
## [154] ".subset2"             "environment&lt;-"        "emptyenv"            
## [157] "seq_len"              ".External2"           "is.symbol"           
## [160] "class"                "on.exit"              "is.raw"              
## [163] "for"                  "is.complex"           "list"                
## [166] "invisible"            "is.character"         "oldClass&lt;-"          
## [169] "is.environment"       "attributes"           "break"               
## [172] "return"               "attr"                 "tracemem"            
## [175] "next"                 ".Call.graphics"       "standardGeneric"     
## [178] "is.atomic"            "retracemem"           "expression"          
## [181] "is.expression"        "call"                 "is.object"           
## [184] "pos.to.env"           "attributes&lt;-"         ".primUntrace"        
## [187] "...length"            ".External"            "oldClass"            
## [190] ".Internal"            ".Fortran"             "browser"             
## [193] "is.double"            ".class2"              "while"               
## [196] "nzchar"               "is.list"              "lazyLoadDBfetch"     
## [199] "...elt"               "...names"             "is.integer"          
## [202] "is.function"          "is.recursive"         "seq_along"           
## [205] "unlist"               "as.vector"            "lengths"
```

---
## Package functions

List all objects in package (data + functions)

```r
library(geospaar)
print(ls("package:geospaar"))
```

```
##  [1] "chirps"      "chirpsz"     "dem"         "distsrfarm"  "farmers_env"
##  [6] "plot_noaxes" "rain_stack"  "raintot"     "raintotalb"  "zamprec"    
## [11] "zonemu"
```



List functions in package

```r
lsf.str("package:geospaar")
```

```
## plot_noaxes : function (x, axes = FALSE, box = FALSE, mar = c(0, 0, 1, 4), ...)
```
---

## Environments
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="figures/class5_envs.png" alt="http://adv-r.had.co.nz/Environments.html" width="70%" /&gt;
&lt;p class="caption"&gt;http://adv-r.had.co.nz/Environments.html&lt;/p&gt;
&lt;/div&gt;
---

## Environments
- Global environment
- Package environment
    - external interface to package - how we find functions 
- Namespace environment
    - internal interface to package - how functions find variables
- Function environment (see http://adv-r.had.co.nz/Environments.html#function-envs)
  - Enclosing environment
  - Binding environment
  - Execution environment

---

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="figures/class3_env_nsp.png" alt="Credit: Lei Song" width="50%" /&gt;
&lt;p class="caption"&gt;Credit: Lei Song&lt;/p&gt;
&lt;/div&gt;

---

`search()` shows the current environments in order. So if a function `select` is called, it first looks in the GlobalEnv, then each package environent.

```r
library(dplyr)
detach(package:dplyr)
library(raster)
library(dplyr)
```

```
## 
## Attaching package: 'dplyr'
```

```
## The following objects are masked from 'package:raster':
## 
##     intersect, select, union
```

```
## The following objects are masked from 'package:stats':
## 
##     filter, lag
```

```
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
```

```r
search()
```

```
##  [1] ".GlobalEnv"        "package:dplyr"     "package:geospaar" 
##  [4] "package:forcats"   "package:stringr"   "package:purrr"    
##  [7] "package:readr"     "package:tidyr"     "package:tibble"   
## [10] "package:ggplot2"   "package:tidyverse" "package:sf"       
## [13] "package:raster"    "package:sp"        "package:stats"    
## [16] "package:graphics"  "package:grDevices" "package:utils"    
## [19] "package:datasets"  "package:methods"   "Autoloads"        
## [22] "package:base"
```
---

You can also see the environments (and their objects) in Rstudio
&lt;img src="figures/class6_rstudio_env.png" width="80%" style="display: block; margin: auto;" /&gt;

---
Using `x` in a function does not change its global value.

```r
x &lt;- 1:10
myfun &lt;- function() {
  x * 10
}
myfun()
```

```
##  [1]  10  20  30  40  50  60  70  80  90 100
```

```r
myfun &lt;- function(x) {
  x &lt;- x * 10
  return(x)
}
x &lt;- 10
myfun(x = 20)
```

```
## [1] 200
```

```r
x
```

```
## [1] 10
```

---
Each time you run `myfun`, a new function environment is created.

```r
myfun &lt;- function(x) {
  x &lt;- x * 10
  print(environment())
  return(x)
}
myfun(x)
```

```
## &lt;environment: 0x0000020c4953ac80&gt;
```

```
## [1] 100
```

```r
myfun(x)
```

```
## &lt;environment: 0x0000020c494b4500&gt;
```

```
## [1] 100
```

---
## Global assignment.
Use `&lt;&lt;-` to change value of global variable within a function.



```r
a &lt;- 10
myfun &lt;- function(x) {
  a &lt;&lt;- x * 10   ## note &lt;&lt;- instead of &lt;- 
  return(a)
}
myfun(5)
```

```
## [1] 50
```

```r
print(a)
```

```
## [1] 50
```



---
## The R Ecosystem
### Data structures
- Atomic vectors (most commonly thought of kind):

  * A sequence of objects of the **same class**.
  * Arrays and matrices are vectors with more than one dimension.
  
      - Matrices have 2 dimensions.
      - Arrays could have higher dimensions.

- Lists

  * Lists can contain objects of **different classes**.
  * Lists can be converted list-matrix or list-array by defining dimensions.
  * `data.frame` and `tibble` are S3 objects that are lists in tabular form

---
## The R Ecosystem
### Data structures
- 1d
- 2d
- 3d



---
## Indexing vectors

Accessing elements in a vector

```r
v &lt;- 1:10 + 5
print(v)
```

```
##  [1]  6  7  8  9 10 11 12 13 14 15
```

```r
print(v[1:3])
```

```
## [1] 6 7 8
```

```r
print(v[c(4,5,8)])
```

```
## [1]  9 10 13
```
---

Only odd elements


```r
v &lt;- 1:10 + 5
print(v %% 2 == 1) ## check if each element is odd
```

```
##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
```

Subset to only odd elements

```r
v_odd &lt;- v[v %% 2 ==1] # use brackets to subset based on condition
v_odd
```

```
## [1]  7  9 11 13 15
```

Set even elements to NA


```r
v[v %% 2 == 0] &lt;- NA 
v
```

```
##  [1] NA  7 NA  9 NA 11 NA 13 NA 15
```

---
## Indexing lists


```r
v1 &lt;- 1:3
v2 &lt;- 4:6
v3 &lt;- 7:9
l &lt;- list(a = v1, b = v2, c = v3)
print(l)
```

```
## $a
## [1] 1 2 3
## 
## $b
## [1] 4 5 6
## 
## $c
## [1] 7 8 9
```

```r
print(names(l))
```

```
## [1] "a" "b" "c"
```

---
Access lists using `$` or `[[ ]]`

```r
print(l$a)
```

```
## [1] 1 2 3
```

```r
print(l$a[3]) # 3rd element of object a
```

```
## [1] 3
```

```r
print(l[[2]])
```

```
## [1] 4 5 6
```

```r
print(l[[2]][3]) # 3rd element of 2nd object
```

```
## [1] 6
```

---
## Indexing Matrices

```r
m &lt;- cbind(a = 1:5, b = 6:10)
print(class(m))
```

```
## [1] "matrix" "array"
```

```r
print(m)
```

```
##      a  b
## [1,] 1  6
## [2,] 2  7
## [3,] 3  8
## [4,] 4  9
## [5,] 5 10
```

Access 2nd row

```r
m[2,]
```

```
## a b 
## 2 7
```
Access 2nd column

```r
m[ , 2]
```

```
## [1]  6  7  8  9 10
```

Access column named 'a'

```r
m[ , 'a']
```

```
## [1] 1 2 3 4 5
```

---
Access 3rd row, 2nd column

```r
m[3 , 2]
```

```
## b 
## 8
```

Set row names

```r
rownames(m) &lt;- LETTERS[10:14]
print(m)
```

```
##   a  b
## J 1  6
## K 2  7
## L 3  8
## M 4  9
## N 5 10
```


---


## Create your own data

- Create the following:
  - `a`: a random vector of integers with 10 elements drawn from 1-20:
    - Use the `sample` function with `set.seed(10)`
    - Name the elements of `a` with a vector of names starting with "V1" and ending with "V10". 
      - Use the `paste0` function to create those names.
      - Create the identical vector of names using the `paste` function.
  - `b`: Using `a` as an index to select from `letters`
  - `d`: Use `rnorm` with a mean = 100 and an sd of 20
    - Use `?rnorm` to see the help guide.
  - Why did I skip `c`? 
  - Create a list `l` from `a`, `b`, `d`. 
    - Assign the names of the vectors in `l` to the `l`'s elements

---
## 2-d structures

- Create the following:
  - `m`: a matrix with three integer columns named "V1", "V2", "V3"
    - Create each column first as its own vector, then combine
    - `V1` = 1:10
    - `V2` is a random sample between 1:100
    - `V3` is drawn from a random uniform distribution between 0 and 50     - Use the same `set.seed(50)` as before
    - Inspect the `str` and `class` of `m`
  - `dat`, a data.frame built from `V1`, `V2`, `V3`, and `V4`
    - `V4` is a random selection of the letters A-E

---
## Homework
- Work on exercises
- Finish reading 1.3
- Read on [tidyr, (12.1 - 12.2)](https://r4ds.had.co.nz/tidy-data.html)

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
