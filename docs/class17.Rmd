---
title: "Geospatial Analysis with R"
subtitle: Class 17
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "lucy", "middlebury-fonts", "themes/class18.css"]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r, echo=FALSE, out.width="50%", results='hold'}
dem1 <- "figures/zam_dem_raster.png"
dem2 <- "figures/zam_dem_stars.png"
knitr::include_graphics(c(dem1, dem2))
```

---

## Today

- Challenge from last class
- Raster intro
  - classes
  - dummy rasters
  - reading and writing
  - rasterize, raster to vector

agg/disagg, masking
assigning values
zonal
focal
cellStats

---
## Project overview
- Due in several weeks
- [Link](https://agroimpacts.github.io/geospaar/projects.html#project-overview-assignment)


---
- Load data
```{r, message = F}
library(geospaar)
farmers <- system.file("extdata/farmer_spatial.csv", package = "geospaar") %>% 
  read_csv() %>% st_as_sf(coords = c("x", "y"))
districts <- st_read(system.file("extdata/districts.shp", package = "geospaar"))
roads <- read_sf(system.file("extdata/roads.shp", package = "geospaar"))
mypoly <- st_polygon(list(cbind(x = c(26.5, 27.5, 27, 26, 26.5), 
                             y = c(-15.5, -16.5, -17, -16, -15.5)))) %>%
  st_sfc(crs = 4326) %>% st_intersection(., districts) %>% st_as_sf() %>% 
  mutate(ID = seq(1: NROW(.)))
#st_crs(mypoly) <- 4326
smallest_centroid <- districts %>% filter(distName == "Lusaka") %>% st_centroid()
```






---
### A quick demo of multi-panel plots
- gridExtra
```{r}
library(ggplot2)

p <- ggplot(districts) + geom_sf() + 
  geom_sf(data = smallest_centroid, color = "red")

p1 <- p + geom_sf(data = mypoly, aes(color = as.factor(ID)),
                  fill = "transparent") + labs(color = "ID")
# small_pol2 <- pol %>% st_sfc() %>% st_sf(crs = 4326) %>% mutate(ID = 1)
p2 <- p + geom_sf(data = mypoly, aes(color = as.factor(ID)),  
                  fill = "transparent") + labs(color = "ID")

gridExtra::grid.arrange(p1, p2, ncol = 2)
```


---
- cowplot::plot_grid
```{r}
g1 <- cowplot::plot_grid(p1 + theme(legend.position = "none"), 
                         p2 + theme(legend.position = "none"))
cowplot::plot_grid(g1, cowplot::get_legend(p1), rel_widths = c(2, 0.3))



```

---

- patchwork

```{r}
library(patchwork)
(p1 / p2) | p2 + plot_layout(guides = "collect")
```



---
### `patchwork`
```{r, eval=FALSE}
library(patchwork)

p1 + p2 + plot_layout(guides = "collect")

p1 + p1 / p
(p1 / p) + (p2 / p)
(p1 + p2) / (p + p)

```

---

## raster objects
- [Raster classes](https://rspatial.org/raster/pkg/2-classes.html)
- `RasterLayer` object - 1 layer
- `RasterStack` object - many layers, multiple file sources
- `RasterBrick` object - many layers, fast, one file source (good for satellite imagery)

---
## accessing bands
- use list `[[ ... ]]` notation
```{r}
data(chirps)
chirps[[3]] ## access by index
#chirps[["Y16301"]] ## access by band name
```

```{r}
plot(chirps[[3]])
```

---

## Creating raster from scratch

- how does `extent` work?
```{r, message = FALSE}
library(raster)
r <- raster(extent(30, 31, -14, -13), res = 0.1, crs = 4326)
values(r) <- sample(1:10, size = ncell(r), replace = TRUE)

par(mar = c(0, 0, 0, 0))
plot(districts %>% st_geometry)
plot(r, add = TRUE)
```

---
- Creating multi-layer stack

```{r, message = FALSE}
s <- stack(r, log10(r))
names(s) <- c("dummy", "log10dummy")
plot(s)
print(class(s))
b <- brick(s)
brick(list(r, log10(r)))
plot(b)
```


---
- Creating multi-layer brick
- what are the dimensions of this raster? resolution?
- how are the values filled?

```{r, message = FALSE}

b2 <- lapply(1:10, function(x) {
  r <- raster(extent(30, 31, -14, -13), res = 0.1, 
              crs = "+proj=longlat +datum=WGS84")
  set.seed(x)
  values(r) <- sample(1:10, size = ncell(r), replace = TRUE)
  r
}) %>% brick
plot(b2)
```

---
### A large brick
- how does this differ from above?
```{r, message = FALSE}
b3 <- lapply(1:10, function(x) {
  r <- raster(extent(30, 31, -14, -13), res = 0.001, 
              crs = "+proj=longlat +datum=WGS84")
  set.seed(x)
  values(r) <- sample(1:10, size = ncell(r), replace = TRUE)
  r
}) %>% stack %>% brick
plot(b3)
plot(b3[[1]])
plot(b3[[10]])
plot(b3[[c(1, 10)]])

```

---
## read and write

```{r, message = FALSE}
## write raster
writeRaster(r, filename = file.path(tempdir(), "mydummy.tif"), overwrite = TRUE)
dir(tempdir())

## read in raster
r <- raster(file.path(tempdir(), "mydummy.tif"))
plot(r)
```

---
## read and write

- `brick` function can be used both to read and write
```{r, message = FALSE}
## write file
brick(s, filename = "mybrick.tif", overwrite = TRUE)

## read file
newbrick <- brick( "mybrick.tif")
```

-  `raster()` only reads in one layer

```{r, eval = FALSE}
a <- raster("mybrick.tif")
nlayers(a)
```

---

## Projecting
- `projectRaster` 
- similar to `st_transform()`, use crs of existing layer to project
- need to define resolution with `res` argument
```{r, message = FALSE}
roads <- read_sf(system.file("extdata/roads.shp", package = "geospaar"))
chirpsz_alb <- chirpsz %>% projectRaster(., crs = crs(roads), res = 5000) 
chirpsz_alb %>% print()
```

---
## Vector <--> Raster
- `rasterize` converts to raster. Need to pass argument that gives raster dimensions.
- In below example, we use `chirpsz` for dimensions
```{r, message = FALSE}
distsr <- districts %>% rasterize(., chirpsz)
distsr %>% plot_noaxes
print(str(distsr))
# stack(distsr, chirpsz[[1:2]]) %>% plotRGB(stretch = "lin")

```

---
## Vector <--> Raster
- `rasterToPolygons`, use dissolve to merge common raster values
```{r}
distsr_pol <- rasterToPolygons(distsr, dissolve = TRUE)
distsr_pol %>% st_as_sf %>% st_geometry %>% plot
distsr_pol %>% st_as_sf %>% slice(49) %>% plot(add = TRUE)
```




---
## Plotting
- run examples below individually
```{r, eval = FALSE}
plot(b)
plot(b2)
plot_noaxes(b)
plot_noaxes(b2, main = paste("Random", 1:10))
plot(b2, main = paste("Random", 1:10))
plot_noaxes(b, legend = FALSE)
```

---
```{r, eval = FALSE}

plot_noaxes(b[[1]], legend = FALSE)
legend("right", legend = 1:10, fill = terrain.colors(10), border = FALSE, 
       bty = "n")
```

---
```{r, eval = FALSE}
# plotting with larger datasets
plot_noaxes(b3, main = paste("Random", 1:10))
plot_noaxes(b3, nc = 3, nr = 4, main = paste("Random", 1:10))
```

---
- rasterVis package includes additional plot options
```{r, eval = FALSE}
rasterVis::levelplot(b3)#, #names.attr = paste("Random", 1:10))
rasterVis::levelplot(b2, names.attr = paste("Random", 1:10))
rasterVis::levelplot(b[[1]])
rasterVis::gplot(b[[1]]) + geom_tile(aes(fill = value)) + 
  scale_fill_viridis_c()
```

---
- ggplot() works with `geom_raster()`
```{r, eval = FALSE}
ggplot2::ggplot(as.data.frame(b[[1]], xy = TRUE)) + 
  # geom_tile(aes(x = x, y = y, fill = dummy)) + scale_fill_viridis_c()  
  geom_raster(aes(x = x, y = y, fill = dummy)) + scale_fill_viridis_c()
```


---
- stars package

```{r, eval = FALSE}
stars::st_as_stars(b) %>% plot(col = viridis::viridis(10))
stars::st_as_stars(b) %>% plot()
```

---
## Raster to other types
```{r, eval=FALSE}
plot(b)
b[1:10]
b[1:ncell(b)]
as.matrix(b)
as.data.frame(b) %>% as_tibble()
```


---
## Pre-processing
- Aggregating/disaggregating
- what is default method for aggregating?
```{r, eval = FALSE}
plot(b, main = paste0("Brick ", 1:2) )
aggregate(b, fact = 2) %>% plot(., main = paste0("Brick agg", 1:2) )
# aggregate(b, fun = min, fact = 2) %>% plot
# aggregate(b, fun = sd, fact = 2) %>% plot
```

---

## Pre-processing
- what is default method for disaggregating?
```{r, eval = FALSE}
plot(b, main = paste0("Brick ", 1:2) )
disaggregate(b, fact = 2) %>% plot(., main = paste0("Brick disagg", 1:2) )
disaggregate(b, fact = 2, method = 'bilinear') %>% plot(., main = paste0("Brick disagg bilinear", 1:2) )
```



---
- Masking
- `mask` makes values `NA` outside of mask area.
```{r, eval = FALSE}
library(geospaar)
data(chirps)
plot_noaxes(chirps[[1]])
chirpsz <- mask(chirps, districts)
plot_noaxes(chirpsz[[1]])
plot(st_geometry(districts), add = TRUE)
# rasterVis::levelplot(chirpsz[[1:5]])
```

---

```{r}
plot_noaxes(chirpsz, nr = 3, nc = 4, maxnl = 12, mar = c(0, 0, 0, 0), 
            legend = FALSE, zlim = c(0, 50))
# plot(chirpsz, nr = 3, nc = 4, maxnl = 12, mar = c(0, 0, 0, 0), 
#      legend = FALSE, zlim = c(0, 50))
```


---

## Calculations

- raster algebra
- statistics
- z dimension stats


---
## Calculations
- math operations work cell-wise
```{r, eval=FALSE}
rf1 <- chirpsz[[1]] + chirpsz[[2]]
rf2 <- chirpsz[[1]] * 5
```

```{r, eval = FALSE}

# dev.off()
plot(rf1 / 1000)
plot(((log10(rf1 + 1) * 10) / 5)^2)

```

---
## `cellStats`
- `cellStats` applies a function (`max`) to all cells in layer 
- `zlim =` argument defined min and max of color ramp 
```{r, eval = FALSE}
mx <- cellStats(rf2, max)
zl <- c(0, mx)
par(mfrow = c(2, 2))
plot(chirpsz[[1]], zlim = zl)
plot(chirpsz[[2]], zlim = zl)
plot(rf1, zlim = zl)
plot(rf2, zlim = zl)
```



---
## `cellStats`
- other `cellStats` options
- apply to single layer
```{r, eval=FALSE}
# mean(c(1, 4, 10, NA), na.rm = TRUE)
cellStats(chirpsz[[1]], stat = mean)
cellStats(chirpsz[[1]], stat = range)
```

---
## `cellStats`
- apply cellStats to multiple layers
- `cellStats` always works one layer at a time. 
-  if input has 28 layers, `cellStats` returns 28 values.

```{r, eval=FALSE}
cellStats(chirpsz, stat = mean)
cellStats(chirpsz, stat = sum)
cellStats(chirpsz, stat = range)
cellStats(chirpsz, summary)
```


---
### `calc` (z-dimension, i.e. layers)
- `calc` looks at all layers together.
- `calc(brick, mean)` will find the pixel-wise mean across all layers
- how would you interpret below?
```{r, eval=FALSE}
plot(calc(chirpsz, mean))
plot(calc(chirpsz, sum))
plot(calc(chirpsz, range))
```

---

## neighborhoods
- `focal` applies window functions, e.g. high-pass or low-pass filters
- what is `w` below?

```{r, eval=FALSE}
raintot <- calc(chirpsz, fun = sum)
w <- matrix(1, nrow = 5, ncol = 5)
rainwindow <- focal(raintot, w = w, fun = mean, na.rm = TRUE)
rainwindow2 <- focal(raintot, w = w, fun = mean)
rainwindow3 <- focal(raintot, w = w, fun = sd)
```

---
- what is difference between plots below?
```{r, eval=FALSE}
par(mfrow = c(2, 2), mar = rep(0, 4))
plot_noaxes(raintot, legend = FALSE)
plot_noaxes(rainwindow, legend = FALSE)
plot_noaxes(rainwindow2, legend = FALSE)
plot_noaxes(rainwindow3, legend = FALSE)
```

---

## zonal stats
- `resample` used to match extent
- `zonal` averages values by district (although districts have been rasterized)
```{r, eval=FALSE}
distsr_rs <- resample(x = distsr, y = chirpsz, method = "ngb")  # match extent between districts raster and chirpsz
zonemu <- zonal(x = chirpsz, z = distsr_rs, fun = "mean")
head(zonemu)[, 1:5]
```




---

## zonal stats
- `subs()` used to convert daily precip values from table to raster
- let's examine piped command
```{r, eval=FALSE}
distr_rfmu <- zonemu %>% data.frame %>% dplyr::select(1:2) %>% 
  subs(x = distsr_rs, y = ., by = "zone")
plot_noaxes(distr_rfmu)
```

---
## selecting and resetting values
- first calculate quartiles for total rainfall over all days
```{r}
raintot <- calc(chirpsz, fun = sum)
print(quantile(raintot))
#rainclasses <- raintot

```

---
- now reclass based on quartiles
  - class 1: < 37 mm
  - class 1: 37 - 60 mm
  - class 2: > 60 mm
```{r}
rainquant <- raintot ## make a copy of total rainfall object
rainquant[raintot < 37] <- 0
rainquant[(raintot > 37) & (raintot < 60)] <- 1
rainquant[raintot > 60] <- 2
plot(raintot)
plot(rainquant)
```

---
## Calculations

- raster algebra
- statistics
- z dimension stats

---
## Exercises

- Create a dummy raster (sampling from 1:100) using district 49 for extent and res of 0.1
- Reproject to Albers
- Disaggregate to 0.02 degrees (bilinear and NGB)
- Calculate the sum of rainfall from `chirps`
- Identify all areas of total rainfall > 10 mm. Set these cells to 1 and other cells to 0.
- Calculate the mean rainfall in Zambia for the 15th day in `chirps`

---
## HW
- Review exercises
- Read Unit 2 Module 2b, Parts 1-2
- [Raster classes](https://rspatial.org/raster/pkg/2-classes.html)
- HW 5 due Sat 4/8


