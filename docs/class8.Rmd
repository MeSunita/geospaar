---
title: "Geospatial Analysis with R"
subtitle: Class 8
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "lucy", "middlebury-fonts", "themes/class8.css"]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
```{r, eval=FALSE}
library(sf)
library(dplyr)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
data(world.cities, package = "maps")

world <- ne_countries(scale = "medium", returnclass = "sf")
afr_capitals <- world.cities %>% filter(capital == 1) %>% 
  st_as_sf(coords = c("long", "lat"), crs = 4326) %>% 
  st_intersection(., world %>% filter(continent == "Africa"))
p <- world %>% filter(continent == "Africa") %>% 
  ggplot() + geom_sf(aes(fill = name), lwd = 0.2) + 
  geom_sf(data = afr_capitals, col = "blue", size = 0.5) + 
  scale_fill_grey(guide = FALSE) + theme_minimal()
ggsave(here::here("external/slides/figures/africa_capitals.png"), 
       width = 5, height = 4, dpi = 300, bg = "transparent")
```

---

```{r, eval=FALSE}
library(stars)
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
x <- read_stars(tif)
plot(x, axes = TRUE)
plot(x[, , , 4:2], axes = TRUE)

s3url <- glue::glue("/vsis3/activemapper/",
                    "planet/composite_sr_buf_fix/GS/",
                    "tile486317_736815_736967.tif")  # not accessible
p <- read_stars(s3url, proxy = TRUE)
plot(p[, , , 1:3])
```

See [here](https://r-spatial.github.io/stars/articles/stars1.html) for more details.

---
## Let's - a -go


---
## MarioKart 

We will examine data from sample MarioKart races. First, let's generate results for 10 races and 4 drivers.

Setup: Create an empty data-frame with 4 columns as follows.
```{r}
DF <- data.frame(mario = integer(),
                luigi = integer(),
                bowser = integer(),
                yoshi = integer())
```

---
## for loop

Use a for loop to fill in the rows 1:10 with the finishing position of each racer. So you should used `sample` to determine finishing order with 4 racers.

Setup: Create an empty data-frame with 4 columns as follows.
```{r, eval = FALSE}
for(k in 1:10){
  DF[k, ] <-  sample(1:4, 4)       ## fill in code here for the kth row
  
}
DF
```

Add row names "race 1", "race 2" etc. Use `paste0`
```{r, eval = FALSE}
rownames(DF) <-  paste0("race ", 1:10)       ## add code here
```
---
## apply work

Calculate the average finishing place of each racer using `apply`. Which dimension will you use? (1 = column, 2 = row).

Which racer had the best average finish?

```{r, eval = FALSE}
average_finish <- apply(DF, 2, FUN = mean) ## fill in code for apply
```


---
## apply work

Now create a new column, `first_place_name` that lists which racer finished first.

You will want to do this in two steps. First use `apply` to get the index of the first place finisher in each row. (hint: you'll want to use one of the `which` functions)

```{r, eval = FALSE}
DF$first_place <- apply(DF, 1, which.min) ## fill in code
```

Then create the `first_place_name` column that uses the racer names. 

```{r, eval = FALSE}
racer_names <- colnames(DF)[1:4]
DF$first_place_names <- racer_names[DF$first_place]
```


---
## Scenario 2.

We will create a new data frame, `DF2`, with one column for each racer. Instead of using `sample` to get the final place, use `runif` to draw each racer's final time from a uniform distribution between 20 and 30 seconds.  

```{r, eval = FALSE}
DF <- data.frame(mario = integer(),
                luigi = integer(),
                bowser = integer(),
                yoshi = integer())

for(k in 1:10){
  DF[k, ] <-  runif(...)       ## fill in code here for the kth row
  
}
```

Again create a column `first_place_name` for the first_place finisher.

Also, create a column `close_race` that is TRUE if the first and last place finishers are within 5 seconds of each other. 

---
## CHALLENGE

Use `rnorm` to determine each racer's times. You will need to fill in the times by column, instead of by row. 
Assume each racer has an average time of 25 seconds, but with different standard deviations. 

Generate data for 1000 races. How often did each driver win?


---
## Assignment 2
- Some small changes made. Be sure to check for updates by reloading website. 



---
# Programming tip

- Whenever possible, let the computer do your counting for you:
```{r}
a <- 1:1001
a[length(a)]
```
- Rather than 
```{r}
a[1001]
```
- Imagine this case:
```{r}
set.seed(1)
b <- 1:sample(1:10000, 1)
b[length(b)]
```

---
## Error message
- `Error: attempt to use zero-length variable name` message
- This occurs in RMD when you have an R chunk immediately followed by a page break `---`
- Add an extra line between R chunk and page break.


---


# Today

- `tidyverse` and `dplyr`
- Reading and writing non-spatial data
- Data preparation/shaping

---

## Next module
- Basic analyses
- Visualization (non-spatial)

---

## data.frame vs. tibble vs data.table
- [good overview](https://jtr13.github.io/cc21fall2/comparison-among-base-r-tidyverse-and-datatable.html)
- Today we will compare `data.frame` and `tibble`
- `data.table` is fast, but its syntax is quite different so we will not use it.

---
## [Advantages of tibble](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html)
- Doesn't change input data type (i.e. doesn't convert strings to factors)
- No row names (rationale: if row name contain important information, they should be placed in a variable)
- Works well with tidy data

---
## What is tidy data?
- In tidy data:
  - Each variable forms a column.
  - Each observation forms a row.
  - Each type of observational unit forms a table.
  
---
## What is tidy data?
- The `tidyverse` packages (`dplyr`, `ggplot2`) are designed to work with tidy data.
- Messy data is any other arrangement of the data.

---
## `dplyr` syntax
- [Style guide](https://style.tidyverse.org/pipes.html). Please read.
- Pipe operator ` %>% ` is used often with `dplyr`.
- ` %>% ` works left to right, evaluating first function, and sending it as input to next function.

Example. What is this code doing?
```{r, message= F}
library(dplyr)
b <- sample(1:100, 10)
print(b)
a <- b %>% max() %>% sqrt()
a
```

---
## `dplyr` syntax
```{r, message=F}
data_tib <- readr::read_csv("~/geospaar/inst/extdata/cdf_corn.csv")
site_summary <- data_tib %>% group_by(site_id) %>% summarise(maxNDVI = max(NDVI))
print(site_summary)
```

---
## Ground sensor data
- We'll look at ground sensor data for sites in Nebraska and California.
- These sensors measure surface reflectance in specific bands. 

```{r, out.width = "40%", out.height= "40%", echo=FALSE, fig.align='center'}
knitr::include_graphics("figures/class8_MarkSensor.png")
```

---
## Reading data
Base R

```{r, results = 'hide'}
data_df <- read.csv("~/geospaar/inst/extdata/cdf_corn.csv")
data_df
```

Tidyr
```{r, results='hide', message = F}
data_tib <- readr::read_csv("~/geospaar/inst/extdata/cdf_corn.csv")
data_tib
```

---
## Selecting data (rows)

Select rows from site "UNLEN_CSP1_IMZ1" 

Base R 
```{r, results='hide', message = F}
data_df[data_df$site_id == "UNLEN_CSP1_IMZ1", ]
```

Tidyr

```{r, results='hide', message = F}
data_tib %>% filter(site_id == "UNLEN_CSP1_IMZ1")
```

Q: How to get observations at site "UNLEN_CSP1_IMZ1" where NDVI is higher than 0.8?

---
## Selecting data (columns)

Select rows from site "UNLEN_CSP1_IMZ1". Only include columns for "local", "lat", "long", "NDVI". 

Base R 
```{r, results='hide', message = F}
data_df[data_df$site_id == "UNLEN_CSP1_IMZ1", c("local", "lat", "long", "NDVI")]
```

Tidyr

```{r, results='hide', message = F}
data_tib %>% filter(site_id == "UNLEN_CSP1_IMZ1") %>% select(local, lat, long, NDVI)
```

What differences do you observe?

---
## Renaming data

Rename "local" to "time", and "site_id" to "site"

Base R- CLUNKY, prone to error
```{r, results='hide', message = F}
colnames(data_df)[colnames(data_df) %in% c("local", "site_id")] =c("time", "site")
```

Tidyr - must store in object to make changes permanent.

```{r, results='hide', message = F}
data_tib %>% rename(time = local, site = site_id)   ## new name = old_name
data_tib ## name change is not permanent
```

```{r, results='hide', message = F}
data_tib <- data_tib %>% rename(time = local, site = site_id)   ## new name = old_name
data_tib ## name change IS permanent
```

---
## Creating a new column

The band correspondence for Mark sensor data is [here](https://www.arable.com/wp-content/uploads/2021/10/Arable-Mark-2-w_-Solar-Product-Specifications-20_10.pdf)

We'd like to create a column for the simple ratio = NIR/red. Let's use the NIR1 band for near-infrared reflectance. 

Base R
```{r, results='hide', message = F}
data_df$SR <- data_df$b6r/data_df$b4r
```

Tidyr
```{r, results='hide', message = F}
data_tib <- data_tib %>% mutate(SR = b6r/b4r)
```

---
## Grouping data into another tible 

Create a tibble summarizing data. 

TidyR
```{r}
data_tib %>% group_by(site) %>%  summarize(count = n(),
                                          max_ndvi = max(NDVI, na.rm = T)
                                          ) 

```

Q: What does `n()` do? what about `na.rm`?

---
## More complex column calculations

Finding date of max NDVI

```{r}
site_data <- data_tib %>% group_by(site) %>%  summarize(count = n(),
                                          max_ndvi = max(NDVI, na.rm = T),
                                          max_ndvi_date = time[which.max(NDVI)]
                                          ) 
site_data
```

---
## Sorting

Base R - CLUNKY
```{r, results='hide', message=F}
site_data[order(site_data$count ,decreasing=TRUE),]
```
tidyr
```{r, results='hide', message=F}
site_data %>% arrange(count) ## arrange ascending
site_data %>% arrange(-count) ## arrange descending
```


---
## Dplyr functions
- There are MANY `dplyr` functions. We have just looked at a handful.
- See `dplyr` [cheatsheet](https://www.rstudio.com/wp-content%2Fuploads%2F2015%2F02%2Fdata-wrangling-cheatsheet.pdf%2F)
- Common `dplyr` [functions](https://dplyr.tidyverse.org/reference/index.html)


---
## Practice (1)

Create a short script that does the following.
- Loads `dplyr` library
- Uses `readr::read_csv` to read in sensor data into a tibble `data_tib`
- Uses `mutate` to create new column for GCVI index.
  - Sensor bands are [here](https://www.arable.com/wp-content/uploads/2021/10/Arable-Mark-2-w_-Solar-Product-Specifications-20_10.pdf). Use band 6 as the NIR band.
  - Google formula for GCVI (Green Chlorophyll Veg Index). 
  
---
## Practice (2)
- Install the `lubridate` package, and load it.
- Apply the `as_date` function to the column `local`. Use this to create a new column `date`, that stores the date as a `Date` object.
- [Lubridate cheat sheet](https://github.com/rstudio/cheatsheets/blob/main/lubridate.pdf)



---
## Practice (3)

- As in the example above, create a new tibble, `site_data`, using `group_by` and `summarize`.
- Use `site` as the grouping variable, and include columns for the following:
  - Median lat and median long (why is `median` better than `mean`)
  - Max NDVI and max GCVI
  - Date of max NDVI and date of max GCVI
- `Lubridate` allows us to subtract dates and find their difference in days. Use this to create a new column `date_diff` in `site_data`. This column should show how many days later (or earlier) the NDVI peak occurred compared to the GCVI peak. 

- CHALLENGE: include the `PlantingDate` column in `site_data`. Use `as_date` with the argument `format = format = "%m/%d/%Y"` to convert the planting date to a `date` data type. Determine how many days after the planting the peak NDVI occurred. 



---

## Homework
- Assignment 2 due Tuesday 2/14
- Read Unit 1 Module 4, Part 3
- Read tidy data [overview](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html). Link to full paper [here](https://vita.had.co.nz/papers/tidy-data.pdf).
- Read [tibbles overview](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html)

